from __future__ import annotations
from typing import (
    TypeVar, Generic, Literal, Iterable, Iterator, Union, Optional, 
    overload, cast, TYPE_CHECKING,
)
if TYPE_CHECKING:
    try:
        from typing import Self             # type: ignore[missing-imports]
    except ImportError:
        from typing_extensions import Self  # type: ignore[missing-imports]
from pathlib import Path, PurePosixPath
import argparse
import subprocess
import shlex
import tarfile
from dataclasses import dataclass, field
import os

import numpy as np
import numpy.typing as npt

from cyndilib.wrapper.ndi_structs import FourCC

HERE = Path(__file__).parent.resolve()
DATA = HERE / 'data'
IMAGE_ROOT = DATA / 'images'
IMAGE_ARCHIVE_FILE = DATA / 'images.tar.xz'

# ffmpeg executable
FFMPEG_BIN = os.environ.get('FFMPEG_BIN', 'ffmpeg')

# format string for ffmpeg test sources
TEST_SRC_FMT = '-f lavfi -i {testsrc}=size={width}x{height} -pix_fmt {pix_fmt}'

# format string for ffmpeg raw video input
RAW_SRC_FMT = '-f rawvideo -pixel_format {pix_fmt} -video_size {width}x{height} -i "{filename}"'


# numpy type aliases
INT_8 = np.uint8
INT_16 = np.uint16
INT = Union[INT_8, INT_16]
_IntT = TypeVar('_IntT', bound=INT)
IntArray1d = npt.NDArray[_IntT]
IntArray2d = npt.NDArray[_IntT]
IntArray3d = npt.NDArray[_IntT]
IntArray4d = npt.NDArray[_IntT]

# types for pixel and image formats
Resolution = tuple[int, int]
BPP = Literal[8, 10, 12]
BitDepth = Literal[8, 16]
ChromaSub = Literal['422', '420']
PlaneSpec = Literal['y', 'u', 'v', 'a']


TestSrc = Literal[
    'testsrc2', 'yuvtestsrc', 'rgbtestsrc', 'smptebars', 'smptehdbars',
    'zoneplate', 'colorspectrum',
]
DataFileKey = tuple[Resolution, FourCC, TestSrc]
RESOLUTIONS: list[Resolution] = [
    (32, 18),
    (640, 360),
    (1920, 1080),
]
PREVIEW_RESOLUTIONS: list[Resolution] = [
    (1920, 1080),
]

PATTERNS: list[TestSrc] = ['yuvtestsrc', 'colorspectrum', 'testsrc2']
PlaneNames: list[PlaneSpec] = ['y', 'u', 'v']



def build_ff_cmd(
    input_args: str,
    outfile: Union[str, Path],
    filter_args: str,
    overwrite: bool = True,
    vframes: int = 1
) -> str:
    """Build an ffmpeg command string

    Arguments:
        input_args: Arguments for the input source
        outfile: Output filename
        filter_args: Filter arguments
        overwrite: Whether to overwrite the output file
        vframes: Number of frames to process
    """
    y = '-y' if overwrite else ''
    vf = '' if vframes is None else f'-vframes {vframes}'
    return f'{FFMPEG_BIN} {y} {input_args} {vf} {filter_args} {outfile}'


def run_ffmpeg(
    input_args: str,
    outfile: Union[str, Path],
    filter_args: str = '',
    overwrite: bool = True,
    vframes: int = 1
) -> None:
    """Run an ffmpeg command formatted by :func:`build_ff_cmd`
    """
    cmd_str = build_ff_cmd(
        input_args=input_args,
        filter_args=filter_args,
        outfile=outfile,
        overwrite=overwrite,
        vframes=vframes,
    )
    print(f'{cmd_str=}')
    subprocess.run(shlex.split(cmd_str), check=True)





@dataclass
class DataFile(Generic[_IntT]):
    """Information for a single video frame data file
    """
    file_dir: Path
    """Base directory for the file"""
    width: int
    """Horizontal resolution"""
    height: int
    """Vertical resolution"""
    fourcc: FourCC
    """FourCC code for the pixel format"""
    testsrc: TestSrc
    """Source pattern (generated by ffmpeg)"""

    @classmethod
    def get_file_dir(cls, fourcc: FourCC) -> Path:
        return IMAGE_ROOT / fourcc.name

    @classmethod
    def get_preview_dir(cls, fourcc: FourCC) -> Path:
        return IMAGE_ROOT / 'previews'

    def get_preview_filename(self, comp: Optional[PlaneSpec] = None) -> Path:
        root = self.get_preview_dir(self.fourcc)
        if comp is not None:
            fn = self.get_plane_filename(comp)
            fn = root / fn.name
        else:
            fn = self.get_filename()
            fn = root / fn.name
        fn = fn.with_suffix('.png')
        return fn

    @property
    def key(self) -> DataFileKey:
        """Unique identifier for the data file
        """
        return (self.resolution, self.fourcc, self.testsrc)

    @property
    def resolution(self) -> Resolution:
        """Video resolution as a tuple of :attr:`width` and :attr:`height`"""
        return (self.width, self.height)

    @property
    def chroma_width(self) -> int:
        """Width of the chroma planes

        This is half the :attr:`width` for 4:2:2 and 4:2:0 formats and the full
        :attr:`width` otherwise.
        """
        w = self.width
        return w if self.is_rgb else w >> 1

    @property
    def chroma_height(self) -> int:
        """Height of the chroma planes

        This is half the :attr:`height` for 4:2:0 formats and the full
        :attr:`height` otherwise.
        """
        h = self.height
        return h >> 1 if self.is_420 else h

    @property
    def chroma_resolution(self) -> Resolution:
        """Resolution of the chroma planes as a tuple of :attr:`chroma_width`
        and :attr:`chroma_height`
        """
        return (self.chroma_width, self.chroma_height)

    @property
    def is_rgb(self) -> bool:
        """Whether the pixel format is RGB"""
        return self.fourcc in [FourCC.RGBX, FourCC.RGBA, FourCC.BGRX, FourCC.BGRA]

    @property
    def has_alpha(self) -> bool:
        """Whether the pixel format has an alpha channel"""
        return self.fourcc in [FourCC.RGBA, FourCC.BGRA, FourCC.UYVA, FourCC.PA16]

    @property
    def num_components(self) -> int:
        """Number of components in the pixel format"""
        return 4 if self.has_alpha else 3

    @property
    def depth(self) -> BitDepth:
        """Bit depth of the luma or RGB component(s)"""
        if self.fourcc in [FourCC.P216, FourCC.PA16]:
            return 16
        return 8

    @property
    def is_16_bit(self) -> bool:
        """``True`` if the pixel format is 16-bit"""
        return self.depth == 16

    @property
    def dtype(self) -> type[_IntT]:
        """Numpy data type for the pixel format

        This will be :obj:`numpy.uint8` or :obj:`numpy.uint16` depending on
        :attr:`depth`.
        """
        return cast(type[_IntT], np.uint16 if self.is_16_bit else np.uint8)

    @property
    def is_420(self) -> bool:
        """Whether the pixel format is 4:2:0"""
        return self.fourcc in [FourCC.I420, FourCC.NV12, FourCC.YV12]

    @property
    def filename_fmt(self):
        return f'{self.fourcc.name}_{self.testsrc}_{self.width}x{self.height}'

    def get_packed_size(self) -> int:
        """Get the size of the packed file in bytes
        """
        fn = self.get_filename()
        return fn.stat().st_size

    def get_plane_filenames(self) -> dict[PlaneSpec, Path]:
        """Get the filenames for the individual YUV(A) components

        Raises:
            ValueError: If the pixel format is not YUV

        """
        if self.is_rgb:
            raise ValueError(f'not yuv: {self=}')
        r: dict[PlaneSpec, Path] = {
            comp:self.get_plane_filename(comp) for comp in PlaneNames
        }
        if self.has_alpha:
            r['a'] = self.get_plane_filename('a')
        return r

    def get_non_alpha_fourcc(self) -> FourCC:
        """Get the non-alpha version of this item's :attr:`fourcc`

        Raises:
            ValueError: If the pixel format does not have an alpha channel

        """
        if not self.has_alpha:
            raise ValueError('no alpha')
        d = {
            FourCC.RGBA: FourCC.RGBX,
            FourCC.BGRA: FourCC.BGRX,
            FourCC.UYVA: FourCC.UYVY,
            FourCC.PA16: FourCC.P216,
        }
        return d[self.fourcc]

    def get_non_alpha_id(self) -> DataFileKey:
        """Get the key for the non-alpha version of this item
        """
        return (self.resolution, self.get_non_alpha_fourcc(), self.testsrc)

    def get_filename(self) -> Path:
        """Get the filename containing the raw packed frame data
        (as generated by ffmpeg)
        """
        out_ext = 'rgb' if self.is_rgb else 'yuv'
        fn = f'{self.filename_fmt}.{out_ext}'
        return self.file_dir / fn

    def get_plane_filename(self, comp: PlaneSpec) -> Path:
        """Get the filename containing the data for a single component

        This is only valid for non-RGB formats.

        Arguments:
            comp: Component name ('y', 'u', 'v', 'a')
        """
        assert not self.is_rgb
        out_ext = 'rgb' if self.is_rgb else 'yuv'
        fn = f'{self.filename_fmt}_{comp}.{out_ext}'
        return self.file_dir / fn

    def get_src_array(self) -> IntArray1d[INT_8]:
        """Get the packed frame data as a 1-d numpy array of uint8

        This is the raw data in the file returned from :meth:`get_filename`.
        """
        return np.fromfile(self.get_filename(), dtype=np.uint8)

    def get_component_resolution(self, comp: PlaneSpec) -> Resolution:
        """Get the resolution of a single component

        For chroma components, this will be the :attr:`chroma_resolution`.
        Otherwise, it will be the full :attr:`resolution`.
        """
        if comp in ['u', 'v']:
            return self.chroma_resolution
        return self.resolution

    def get_plane_array(self, comp: PlaneSpec) -> IntArray1d[_IntT]:
        """Get the unpacked data for a single component as a 2-d numpy array

        The shape of the array will be match that of
        :meth:`get_component_resolution` for the given component.

        The dtype of the array will match that of :attr:`dtype`.
        """
        fn = self.get_plane_filename(comp)
        arr = np.fromfile(fn, dtype=self.dtype)
        w, h = self.get_component_resolution(comp)
        return arr.reshape((h, w))

    def get_plane_arrays(self, expand_chroma: bool) -> IntArray3d[_IntT]:
        """Get the unpacked data for all components as a 3-d numpy array

        The array shape will be in packed format (height, width, components).

        Arguments:
            expand_chroma: Whether to expand the chroma planes to full width
                and height. If ``False``, the chroma planes will only fill their
                respective regions in the array. In both cases however, the
                the array shape will be the full :attr:`resolution`.

        """
        assert not self.is_rgb
        w, h = self.resolution
        cw, ch = self.chroma_resolution
        comps: list[PlaneSpec] = ['y', 'u', 'v']
        if self.has_alpha:
            comps.append('a')
        arrs = []
        for comp in comps:
            arr = self.get_plane_array(comp)
            if comp in ['u', 'v']:
                if expand_chroma:
                    arr = np.repeat(arr, 2, axis=-1)
                    if self.is_420:
                        arr = np.repeat(arr, 2, axis=0)
                else:
                    tmp = np.zeros((h, w), dtype=arr.dtype)
                    tmp[:ch, :cw] = arr
                    arr = tmp
            arrs.append(arr)
        return np.stack(arrs, axis=-1)



@dataclass
class DataFileContainer:
    """Collection of :class:`DataFile` instances
    """
    data_files: list[DataFile]
    data_files_by_key: dict[DataFileKey, DataFile] = field(init=False)

    @classmethod
    def create(
        cls,
        fourccs: Optional[Iterable[FourCC]] = None,
        resolutions: Optional[Iterable[Resolution]] = None,
        patterns: Optional[Iterable[TestSrc]] = None,
    ) -> Self:
        fourccs = fourccs or FourCC
        resolutions = resolutions or RESOLUTIONS
        patterns = patterns or PATTERNS
        data_files: list[DataFile] = []
        for fourcc in fourccs:
            for w, h in resolutions:
                for pattern in patterns:
                    data_files.append(DataFile(
                        file_dir=DataFile.get_file_dir(fourcc),
                        width=w, height=h,
                        fourcc=fourcc, testsrc=pattern,
                    ))
        return cls(data_files)

    def __post_init__(self):
        self.data_files_by_key = {
            df.key: df for df in self.data_files
        }

    def __getitem__(self, key: DataFileKey) -> DataFile:
        return self.data_files_by_key[key]

    def __iter__(self) -> Iterator[DataFile]:
        yield from self.data_files

    def iter_files(self) -> Iterator[Path]:
        for df in self:
            yield df.get_filename()
            if df.is_rgb:
                continue
            yield from df.get_plane_filenames().values()

    def by_resolution(
        self,
        resolution: Resolution,
        data_files: Optional[Iterable[DataFile]] = None
    ) -> Iterator[DataFile]:
        data_files = data_files or self
        for df in data_files:
            if df.resolution == resolution:
                yield df

    def by_fourcc(
        self,
        fourcc: FourCC,
        data_files: Optional[Iterable[DataFile]] = None
    ) -> Iterator[DataFile]:
        data_files = data_files or self
        for df in data_files:
            if df.fourcc == fourcc:
                yield df

    def by_testsrc(
        self,
        testsrc: TestSrc,
        data_files: Optional[Iterable[DataFile]] = None
    ) -> Iterator[DataFile]:
        data_files = data_files or self
        for df in data_files:
            if df.testsrc == testsrc:
                yield df

    def by_has_alpha(
        self,
        has_alpha: bool,
        data_files: Optional[Iterable[DataFile]] = None
    ) -> Iterator[DataFile]:
        data_files = data_files or self
        for df in data_files:
            if df.has_alpha is has_alpha:
                yield df

DataFiles = DataFileContainer.create()



def build_datafile_contents(build_previews: bool = False) -> None:
    """Build data files using ffmpeg test sources

    For each resolution and FourCC, build a packed raw file and separate
    files for each component (YUV) using ffmpeg.  This ensures that what's
    being tested matches real-world data as closely as possible
    (not the author's interpretation).

    Formats with alpha channels are skipped here and built in
    :func:`build_alpha_contents`.
    """
    # map of supported ffmpeg pix_fmts for each FourCC
    pix_fmts = {
        'UYVY': 'uyvy422',
        'RGBX': 'rgb0',
        'BGRX': 'bgr0',
        'NV12': 'nv12',
        'I420': 'yuv420p',
        'YV12': 'yuv420p',
        'P216': 'p216be',
    }

    for data_file in DataFiles.by_has_alpha(False):
        pix_fmt = pix_fmts[data_file.fourcc.name]
        w, h = data_file.resolution
        filename = data_file.get_filename()
        data_file.file_dir.mkdir(parents=True, exist_ok=True)

        src_arg = TEST_SRC_FMT.format(
            width=w, height=h, testsrc=data_file.testsrc, pix_fmt=pix_fmt,
        )

        if data_file.fourcc == FourCC.YV12:
            # swap u and v planes for YV12 (pix_fmt not built in)
            filter_arg = '-vf shuffleplanes=0:2:1'
        else:
            filter_arg = ''
        run_ffmpeg(input_args=src_arg, filter_args=filter_arg, outfile=filename)

        raw_src_arg = RAW_SRC_FMT.format(
            width=w, height=h, pix_fmt=pix_fmt, filename=filename,
        )

        if build_previews and data_file.resolution in PREVIEW_RESOLUTIONS:
            # Build a viewable preview just for sanity check
            # png_filename = filename.with_suffix('.png')
            png_filename = data_file.get_preview_filename()
            png_filename.parent.mkdir(parents=True, exist_ok=True)
            run_ffmpeg(input_args=raw_src_arg, outfile=png_filename)

        if data_file.is_rgb:
            continue

        # Use `extractplanes` filter and `-map` on the file created above
        # to create a separate file for each component
        # (with proper chroma width/height)
        plane_filenames = data_file.get_plane_filenames()
        plane_maps = ' '.join([
            f"-map '[{comp}]' {fn}" for comp, fn in plane_filenames.items()
        ])

        if data_file.fourcc == FourCC.YV12:
            # swap u and v planes for YV12 (pix_fmt not built in)
            plane_filt = "-filter_complex 'extractplanes=y+u+v[y][v][u]'"
        else:
            plane_filt = "-filter_complex 'extractplanes=y+u+v[y][u][v]'"

        run_ffmpeg(
            input_args=raw_src_arg, filter_args=plane_filt, outfile=plane_maps,
        )

        if build_previews and data_file.resolution in PREVIEW_RESOLUTIONS:
            for comp, plane_filename in plane_filenames.items():
                png_filename = data_file.get_preview_filename(comp)
                comp_width, comp_height = data_file.get_component_resolution(comp)
                run_ffmpeg(
                    input_args=RAW_SRC_FMT.format(
                        width=comp_width,
                        height=comp_height,
                        pix_fmt='gray16be' if data_file.is_16_bit else 'gray',
                        filename=plane_filename,
                    ),
                    outfile=png_filename,
                )


@overload
def build_alpha_plane(
    width: int,
    height: int,
    depth: Literal[8]
) -> IntArray1d[INT_8]: ...
@overload
def build_alpha_plane(
    width: int,
    height: int,
    depth: Literal[16]
) -> IntArray1d[INT_16]: ...
def build_alpha_plane(
    width: int,
    height: int,
    depth: BitDepth
) -> Union[IntArray1d[INT_8], IntArray1d[INT_16]]:
    # We don't really have a great source for alpha, so just use a simple gradient
    max_int = (1 << depth) - 1
    x = np.linspace(0, max_int / 2, width)
    y = np.linspace(0, max_int / 2, height)
    xy = y[:,np.newaxis] + x[np.newaxis,:]

    # According to the spec, alpha is full-range for the data-type,
    # not range-limited like the other components
    out = np.clip(np.round(xy), 0, max_int)
    if depth == 16:
        return np.asarray(out, dtype=np.uint16)#np.dtype('>H'))
        # # assuming native endianness is le
        # return np.asarray(out, dtype=np.dtype('>H'))
    return np.asarray(out, dtype=np.uint8)


def build_alpha_contents(build_previews: bool = False) -> None:
    """Build the alpha variants of the data files

    The non-alpha components from :func:`build_datafile_contents` are copied
    and the alpha channel is filled with a generated gradient.
    """
    for alpha_file in DataFiles.by_has_alpha(True):
        non_alpha_key = alpha_file.get_non_alpha_id()
        non_alpha_file = DataFiles[non_alpha_key]

        w, h = alpha_file.resolution
        alpha_plane = build_alpha_plane(w, h, alpha_file.depth)

        in_arr = np.fromfile(non_alpha_file.get_filename(), dtype=alpha_file.dtype)
        if alpha_file.is_rgb:
            out_arr = in_arr.reshape((h, w, 4))
            out_arr[...,3] = alpha_plane
            out_arr = out_arr.flatten()
        else:
            out_arr = np.concat((in_arr, alpha_plane.flatten()))
        filename = alpha_file.get_filename()
        filename.parent.mkdir(parents=True, exist_ok=True)
        out_arr.tofile(filename)

        if alpha_file.is_rgb:
            pix_fmt = alpha_file.fourcc.name.lower()
            raw_src_arg = RAW_SRC_FMT.format(
                width=w, height=h, pix_fmt=pix_fmt, filename=filename,
            )

            if build_previews and alpha_file.resolution in PREVIEW_RESOLUTIONS:
                # Build a viewable preview just for sanity check
                # png_filename = filename.with_suffix('.png')
                png_filename = alpha_file.get_preview_filename()
                png_filename.parent.mkdir(parents=True, exist_ok=True)
                run_ffmpeg(input_args=raw_src_arg, outfile=png_filename)
            continue

        for comp, plane_filename in alpha_file.get_plane_filenames().items():
            if comp == 'a':
                a = alpha_plane.flatten()
                a.tofile(plane_filename)
                if build_previews and alpha_file.resolution in PREVIEW_RESOLUTIONS:
                    # Build a preview of the alpha plane
                    # (we already have the other planes from the non-alpha file)
                    png_filename = alpha_file.get_preview_filename(comp)
                    png_filename.parent.mkdir(parents=True, exist_ok=True)
                    # note: Endianness needs to be swapped for some reason:
                    #   The alpha plane is created using native byte-order
                    #   but with pix_fmt='gray16be', the output is incorrect.
                    #   This is only for preview purposes though.
                    run_ffmpeg(
                        input_args=RAW_SRC_FMT.format(
                            width=w,
                            height=h,
                            pix_fmt='gray16le' if alpha_file.is_16_bit else 'gray',
                            filename=plane_filename,
                        ),
                        outfile=png_filename,
                    )
            else:
                # Copy the plane data from the non-alpha file
                # (instead of re-encoding)
                src_filename = non_alpha_file.get_plane_filename(comp)
                plane_filename.write_bytes(src_filename.read_bytes())


def build_all(build_previews: bool) -> None:
    build_datafile_contents(build_previews)
    build_alpha_contents(build_previews)


def compress_files(arch_file: Path = IMAGE_ARCHIVE_FILE) -> Path:
    arch_root = DATA.resolve()
    with tarfile.open(arch_file, 'w:xz') as tar:
        for fn in DataFiles.iter_files():
            rel_fn = fn.resolve().relative_to(arch_root)
            rel_fn = PurePosixPath(*rel_fn.parts)
            tar.add(fn, arcname=rel_fn)
    return arch_file


def decompress_files(arch_file: Path = IMAGE_ARCHIVE_FILE) -> Path:
    arch_root = DATA.resolve()
    assert arch_file.resolve().parent == arch_root
    with tarfile.open(arch_file, 'r:xz') as tar:
        for fn in DataFiles.iter_files():
            rel_fn = fn.resolve().relative_to(arch_root)
            rel_fn = PurePosixPath(*rel_fn.parts)
            inf = tar.getmember(str(rel_fn))
            tar.extract(inf, path=arch_root)
    return arch_root



if __name__ == '__main__':
    p = argparse.ArgumentParser()
    p.add_argument('--decompress', action='store_true')
    p.add_argument('--compress', action='store_true')
    p.add_argument('--build-previews', action='store_true')
    p.add_argument('--no-build', action='store_true')
    args = p.parse_args()
    if args.decompress:
        decompress_files()
    else:
        if not args.no_build:
            build_all(build_previews=args.build_previews)
        if args.compress:
            print('compressing...')
            compress_files()
