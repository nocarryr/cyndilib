from __future__ import annotations

from typing import NamedTuple, Literal, Generator, Any, cast, get_args
from typing_extensions import Self
import enum
import io
import subprocess
import shlex
from fractions import Fraction
from contextlib import contextmanager

import click

from cyndilib.wrapper.ndi_structs import FourCC
from cyndilib.video_frame import VideoSendFrame
from cyndilib.sender import Sender

TestSource = Literal[
    'testsrc2', 'yuvtestsrc', 'rgbtestsrc', 'smptebars', 'smptehdbars',
    'zoneplate', 'colorspectrum',
]

FF_CMD = '{ffmpeg} -f lavfi -i {source}=size={xres}x{yres}:rate={fps} \
    -pix_fmt {pix_fmt.name} -f rawvideo pipe: '



class PixFmt(enum.Enum):
    """Maps ffmpeg's ``pix_fmt`` names to their corresponding
    :class:`FourCC <cyndilib.wrapper.ndi_structs.FourCC>` types
    """
    uyvy422 = FourCC.UYVY   #: uyvy422
    nv12 = FourCC.NV12      #: nv12
    rgba = FourCC.RGBA      #: rgba
    rgb0 = FourCC.RGBX      #: rgb0
    bgra = FourCC.BGRA      #: bgra
    bgr0 = FourCC.BGRX      #: bgr0
    p216be = FourCC.P216    #: p216be
    yuv420p = FourCC.I420   #: yuv420p (i420)

    @classmethod
    def from_str(cls, name: str) -> Self:
        return cls.__members__[name]


class Options(NamedTuple):
    """Options set through the cli
    """
    source: TestSource                  #: Source to use for the test pattern
    pix_fmt: PixFmt                     #: Pixel format to send
    xres: int                           #: Horizontal resolution
    yres: int                           #: Vertical resolution
    fps: str                            #: Frame rate
    sender_name: str = 'ffmpeg_sender'  #: NDI name for the sender
    ffmpeg: str = 'ffmpeg'              #: Name/Path of the "ffmpeg" executable


def parse_frame_rate(fr: str) -> Fraction:
    """Helper for NTSC frame rates (29.97, 59.94)
    """
    if '/' in fr:
        n, d = [int(s) for s in fr.split('/')]
    elif '.' in fr:
        n = round(float(fr)) * 1000
        d = 1001
    else:
        n = int(fr)
        d = 1
    return Fraction(n, d)


@contextmanager
def ffmpeg_proc(opts: Options) -> Generator[subprocess.Popen[bytes], Any, None]:
    """Context manager for the ffmpeg subprocess generating frames
    """
    ff_cmd = FF_CMD.format(**opts._asdict())
    ff_proc = subprocess.Popen(shlex.split(ff_cmd), stdout=subprocess.PIPE)
    try:
        ff_proc.poll()
        if ff_proc.returncode is None:
            yield ff_proc
    finally:
        ff_proc.kill()


def send(opts: Options) -> None:
    """Send frames generated by ffmpeg's ``testsrc2`` as an |NDI| stream

    The raw frames generated by ffmpeg are sent to a pipe and read from its
    :attr:`~subprocess.Popen.stdout`.  The data is then fed directly to
    :meth:`cyndilib.sender.Sender.write_video_async` using an
    intermediate :class:`memoryview`
    """
    sender = Sender(opts.sender_name)

    # Build a VideoSendFrame and set its resolution and frame rate
    # to match the options argument
    vf = VideoSendFrame()
    vf.set_resolution(opts.xres, opts.yres)
    fr = parse_frame_rate(opts.fps)
    vf.set_frame_rate(fr)
    vf.set_fourcc(opts.pix_fmt.value)

    # Add the VideoSendFrame to the sender
    sender.set_video_frame(vf)

    # Pre-allocate a bytearray to hold frame data and create a view of it
    # So we can buffer into it from ffmpeg then pass directly to the sender
    frame_size_bytes = vf.get_data_size()
    ba = bytearray(frame_size_bytes)
    mv = memoryview(ba)

    i = 0
    frame_sent = False

    with sender:
        with ffmpeg_proc(opts) as ff_proc:
            stdout = cast(io.BytesIO, ff_proc.stdout)
            while True:
                i += 1
                if ff_proc.returncode is not None:
                    break
                # Read from the ffmpeg process into a view of the bytearray
                num_read = stdout.readinto(mv)

                # The first few reads might be empty, ignore
                if num_read == 0:
                    if frame_sent:
                        # If we've sent a frame and there's no output,
                        # ffmpeg has likely quit without setting returncode
                        break
                    elif i > 1000:
                        # Check for ffmpeg startup errors
                        print('Timeout waiting for ffmpeg to produce output')
                        break
                    continue
                frame_sent = True
                # Pass the memoryview directly to the sender
                # (using the buffer protocol)
                sender.write_video_async(mv)

                if i % 10 == 0:
                    ff_proc.poll()



@click.command()
@click.option(
    '--source',
    type=click.Choice(
        choices=[m for m in get_args(TestSource)],
    ),
    default='testsrc2',
    show_default=True,
    help='Name of the ffmpeg test source to use',
)
@click.option(
    '--pix-fmt',
    type=click.Choice(choices=[m.name for m in PixFmt]),
    default=PixFmt.uyvy422.name,
    show_default=True,
    show_choices=True,
)
@click.option('-x', '--x-res', type=int, default=1920, show_default=True)
@click.option('-y', '--y-res', type=int, default=1080, show_default=True)
@click.option('--fps', type=str, default='30', show_default=True)
@click.option(
    '-n', '--sender-name',
    type=str,
    default='ffmpeg_sender',
    show_default=True,
    help='NDI name for the sender',
)
@click.option(
    '--ffmpeg',
    type=str,
    default='ffmpeg',
    show_default=True,
    help='Name/Path of the "ffmpeg" executable',
)
def main(
    source: TestSource,
    pix_fmt: str,
    x_res: int,
    y_res: int,
    fps: str,
    sender_name: str,
    ffmpeg: str
):
    opts = Options(
        source=source,
        pix_fmt=PixFmt.from_str(pix_fmt),
        xres=x_res,
        yres=y_res,
        fps=fps,
        sender_name=sender_name,
        ffmpeg=ffmpeg,
    )
    send(opts)


if __name__ == '__main__':
    main()
